package com.softwareag.wm.invoke.audit;

import java.util.*;

import com.wm.app.b2b.server.Service;
import com.wm.app.b2b.server.BaseService;
import com.wm.app.b2b.server.InvokeException;
import com.wm.app.b2b.server.InvokeState;
import com.wm.app.b2b.server.ServiceException;
import com.wm.app.b2b.server.invoke.InvokeChainProcessor;
import com.wm.app.b2b.server.invoke.ServiceStatus;
import com.wm.data.IData;
import com.wm.data.IDataCursor;
import com.wm.data.IDataUtil;
import com.wm.lang.ns.AuditSettings;
import com.wm.lang.ns.NSService;
import com.wm.net.HttpHeader;
import com.wm.util.ServerException;


/**
 * Implements the webMethods InvokeChainProcessor interface to allow services
 * to be intercepted.
 * 
 * Don't forget to update the <SAG_HOME>/IntegrationServer/config/invokemananger.cnf file and add
 * the class of the interceptor class. Otherwise webMethods
 * will not be aware of your interceptor. In addition the classes must be 
 * loaded at startup so ensure that the class is packaged in a static jar
 * 
 * Ideally would want to modify the class com/wm/app/b2b/server/AuditLogManager
 * to include this code as it would ensure that the start audit would also
 * have the correct root context id.
 * 
 * @author John Carter (john.carter@softwareag.com)
 */
public class InvokeInterceptor implements InvokeChainProcessor {
		 
	public static final String 			WM_ENDTOEND_TRANSACTION_ID = "wm-etoe-transaction-id";
	
	/** 
	 * Used to identify the webMethods root context id based in runtime-attribute array
	 * returned by InvokeState. Attention this will have to be tested for each webMethods
	 * version as this is not official.
	 */
	public static final int				WM_ROOT_CONTEXT_ID_INDEX = 0;
	
    private static InvokeInterceptor    _default;
    
    public InvokeInterceptor() {
    	
        System.out.println("Instantiating com.softwareag.wm.invoke.agent.EndToEndAgent");
        _default = this;
        
        _default.startup();
    }
    
    /**
     * Ensures that the default interceptor is properly configured and that
     * all context map are instantiated and hooked up to the backing store
     * 
     * @throws com.wm.app.b2b.server.ServiceException
     */
    public static void restart() throws ServiceException {
        if (_default != null)
            _default.startup();
    }
    
    /**
     * Configures the InvokeInterceptor and ensures the persistence store for
     * storing suspended services is instantiated and working properly
     * 
     * @throws com.wm.app.b2b.server.ServiceException
     */
    private void startup() {
       // TODO:
    }
    
    public void process(@SuppressWarnings("rawtypes") Iterator chain, BaseService baseService, IData pipeline, ServiceStatus status) throws ServiceException {
       
    	String rootContextId = getRootContextId(status); // will NOT force root context id to header value identified by WM_ENDTOEND_TRANSACTION_ID
    	String parentContext = getParentContextId(status); // will be same as root context id if this service is top level!
    	
        String name = getServiceName(baseService); 
     
        try {   	
            if(chain.hasNext()) {
                
                if (chainPreProcessor(rootContextId, name, baseService, pipeline)) {
                	
                	//TODO: Do we want to make audit destination one of file, db or external monitoring or should it be a complement
                	
                	// ASSUMPTION: we logged via etoe, so disable internal logging, don't need to monitor locally.
                	baseService.setAuditOption(BaseService._AUDIT_OFF);
                }
                
                ((InvokeChainProcessor)chain.next()).process(chain, baseService, pipeline, status);
                
                // service success
                
                chainPostProcessor(rootContextId, name, baseService, pipeline, status);
            }
        } catch (InvokeException error) {

        	// service exceptions arrive here
        	chainPostProcessor(rootContextId, name, baseService, pipeline, error);
        	
        	throw new ServiceException(error);
		} catch (ServerException error) {
			throw new ServiceException(error);
		}
    }
    
    /**
     * Either uses wm context id or that provided by end to end monitoring (in which case it updates the invoke status to use it
     * This occurs after the start step of auditing so the IS audit will have it's own unique id, rather than the etoe id, end and error
     * steps will be okay as well as any invoked services.
     * 
     * @param status references current runtime info (but not audit settings strangely)
     * @return the current context id of the service
     */
    protected String getRootContextId(ServiceStatus status) {
        
    	/*if (status.isTopService() && getEtoETransactionId() != null) {
    	 // This won't work SW6 id generated by skywalking cannot be formatted as UUID as so wm won't accept it
        	
        	String id = getEtoETransactionId();
            setRootContextIdForThread(id);

        	return id;
        } else {
        	return Service.getCurrentActivationID();
        }*/
    	
    	if (status.isTopService()) {
    		return Service.getCurrentActivationID();
    	} else {

    		return InvokeInterceptor.getContextIDsForService()[0];
    	}
    }
    
    protected String getParentContextId(ServiceStatus status) {
        	
    	if (status.isTopService()) {
    		return Service.getCurrentActivationID();
    	} else {

    		return InvokeInterceptor.getContextIDsForService()[1];
    	}
    }

    protected String getServiceName(BaseService baseService) {
        return baseService.getNSName().getFullName();
    }
    
    protected String getEtoETransactionId() {
        // TODO: pull from header
    	
    	HttpHeader header = Service.getHttpRequestHeader();
    	return Service.getHttpHeaderField(WM_ENDTOEND_TRANSACTION_ID, header);
    }
  
    
    /**
     * Entry point for end to end monitoring to allow service start to be logged if required
     * 
     * @return true if end to end monitoring is activated, false if not
     */
    protected boolean chainPreProcessor(String integrationId, String serviceName, BaseService baseService, IData pipeline) {
    	
    	boolean didLog = false;
    			
    	// base auditing on requirements from audit sub-system
    	    	
    	if (serviceName.startsWith("wm.tn")) {
    		
    		// TN is a special case, won't do this for any other subproducts, honest!

    		if (serviceName.equals("wm.tn.route:route")) {
        		// processing rule will be called
    			
    		} else if (serviceName.equals("wm.tn.doc:relateDocuments")) {
    			// one document is being related to another i.e. parent or child
    			
    		} else if (serviceName.equals("wm.tn:log")) {
    			// custom logging
    			
    		} else if (serviceName.equals("wm.tn.route:invoke")) {
    			// wrapper for processing rule service
    			
    		} else if (serviceName.equals("wm.tn.delivery:deliver")) {
    			// wrapper for delivery method
    			
    		}
    		
    	} else if (baseService.getAuditOption() == BaseService.AUDIT_ENABLE && baseService.getAuditSettings().isStartAuditEnabled()) {
    		
    		System.out.println("Processing start " + serviceName + " / " + integrationId);
    		
    		String[][] businessDataKeys = baseService.getInputAuditFields();
    		
    		Map<String, Object> businessData = extractDataFromPipeline(businessDataKeys, pipeline);
    		
    		//TODO: 
    		
    		System.out.println("no of keys: " + businessData.size());
    		
    		didLog = true;
    	}
    	
    	return didLog;
    }
    
    /**
     *
     */
    protected void chainPostProcessor(String integrationId, String serviceName, BaseService baseService, IData pipeline, ServiceStatus status) {
    	    	
    	if (serviceName.startsWith("wm.tn")) {
    		
    		// TN is a special case, won't do this for any other subproducts, honest!

    		if (serviceName.equals("wm.tn.route:route")) {
        		// processing rule will be called
    			
    		} else if (serviceName.equals("wm.tn.doc:relateDocuments")) {
    			// one document is being related to another i.e. parent or child
    			
    		} else if (serviceName.equals("wm.tn:log")) {
    			// custom logging
    			
    		} else if (serviceName.equals("wm.tn.route:invoke")) {
    			// wrapper for processing rule service
    			
    		} else if (serviceName.equals("wm.tn.delivery:deliver")) {
    			// wrapper for delivery method
    			
    		}
    	} else if (baseService.getAuditOption() == BaseService.AUDIT_ENABLE && baseService.getAuditSettings().isCompleteAuditEnabled()) {
    			
    			// TODO: report success
    			
        		System.out.println("Processing completion " + serviceName + " / " + integrationId);
        		
        		String[][] businessDataKeys = baseService.getOutputAuditFields();
        		
        		Map<String, Object> businessData = extractDataFromPipeline(businessDataKeys, pipeline);
        		
        		//TODO:
        		
        		System.out.println("no of keys: " + businessData.size());
    	} 
    }
    
    /**
    *
    */
   protected void chainPostProcessor(String integrationId, String serviceName, BaseService baseService, IData pipeline, InvokeException e) {
   	    	  		   		   				
   		// TODO: report here!
	   
	   if (baseService.getAuditSettings().isErrorAuditEnabled()) {
	   		System.out.println("Processing error " + serviceName + " / " + integrationId);   
	   }		   
   }
     
   
   /**
    * Extract given keys from pipeline
    */
   
   protected Map<String, Object> extractDataFromPipeline(String[][] keys, IData pipeline) {
	   
	   Map<String, Object> vals = new HashMap<String, Object>();
	   
	   if (keys != null) {
		   for (String[] k : keys) {
			   Object obj = _extractDataFromPipeline(k[0], pipeline);
		   
			   if (obj != null) {
				   vals.put(k[1], obj); // USED simple name, risky because it might not be be unique, perhaps should use xpath ?
			   }
		   }
	   }
	   
	   return vals;
   }
   
   private Object _extractDataFromPipeline(String xpath, IData doc)
   {
       XPathExpression xpe = new XPathExpression(xpath);
       
       try
       {
           return xpe.getObject(doc);
       }
       catch (Exception e)
       {
           return null;
       }
   }
   
    /**
     * Return the package name associated with the context of the calling service.
     *
     * @return package name associated with the calling context
     */
    public static String getPackageForCaller() 
    {
        return getPackageForCaller(false);
    }
    
    public static String getPackageForCaller(boolean ifNotExistGetCurrent) {
    	
    	String packageName = null;

        try {
            NSService caller = Service.getCallingService();
            if (caller == null && ifNotExistGetCurrent) {
            	packageName = Service.getPackageName();
            } else {
            	packageName = caller.getPackage().getName();
            }
        } catch (Exception e) {
           // throw new RuntimeException("Cannot determine package name");
        }

        return packageName;
    }
    
    protected static String[] getContextIDsForService() {
        
    	String[] contextIDs = {null, null, null};

        try {
            InvokeState currentInvokeState = InvokeState.getCurrentState();
            String contextIDStack[] = currentInvokeState.getAuditRuntime().getContextStack();

            String contextId = null;
            String parentContextId = null;

            int contextId_index = contextIDStack.length - 1;

            contextId = contextIDStack[contextId_index];
            if (contextId_index > 0) {
                parentContextId = contextIDStack[contextId_index - 1];
            }
            
            contextIDs[0] = contextIDStack[0]; // root context id
            contextIDs[1] = parentContextId;
            contextIDs[2] = contextId;
            
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return contextIDs;
    }
    
     /**
      * Forces root context ID to given value
      * Unfortunately audit start event occurs before the class in
      * the invocation chain and will record wm value
      * 
      * activationId must be a valid UUID v1 String
      * e.g. f10f14ac-8297-11eb-8dcd-0242ac130003
      */
	 @SuppressWarnings("unused")
	private static void setRootContextIdForThread(String activationId) {
         
		 if (activationId == null) {
			 return;
		 }
		 
		 		 		 
		 InvokeState is = InvokeState.getCurrentState();
               
          if (is != null)
          {
              String[] args = null;
 
              if (is.getAuditRuntime() != null) {
            	  
            	  args = is.getAuditRuntime().getContextStack();
                  
                  System.out.println("alternatively it is " + args[WM_ROOT_CONTEXT_ID_INDEX]);
                  
                  if (args.length <= WM_ROOT_CONTEXT_ID_INDEX)
                      args = new String[WM_ROOT_CONTEXT_ID_INDEX+1];
                  
                  args[WM_ROOT_CONTEXT_ID_INDEX] = activationId;
                  
                  InvokeState.getCurrentState().getAuditRuntime().setContextStack(args);
              }
          }
     }
}
